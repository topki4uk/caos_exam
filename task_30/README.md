## Как сделать кастомный обработчик сигналов?

* Это можно сделать при помощи сискола `signal`

```shell
  man 2 signal
```

## Покажите на примере, как из кода программы перехватывать `segfault` и делать что-то нестандартное при его наступлении.

```shell
  # Посылаем сигнал
  kill -SIGSEGV $(pgrep mysignal)
```

## Что, если во время обработки сигнала приходит другой сигнал?

```shell
  # Посылаем другой сигнал
  kill -SIGTERM $(pgrep mysignal)
```

## Как можно заблокировать получение других сигналов во время обработки сигнала?

```shell
  man 2 sigaction
```

```shell
  # Посылаем другой сигнал
  kill -SIGTERM $(pgrep block_signals)
```

```shell
  # Посылаем другой сигнал
  kill -SIGSEGV $(pgrep block_signals)
```

##  Что, если сигнал приходит во время выполнения сисколла?

* Если медленный сискол - произойдет прерывание
* Если быстрый - скорее всего не произойдет

```shell
  # Посылаем другой сигнал
  kill -SIGKILL $(pgrep read_eintr)
```

## Что такое `signal-safety` и что такое реентрабельная функция?

`Signal-safety` (асинхронная безопасность) — свойство функции, которое гарантирует, 
что ее можно безопасно вызывать из обработчика сигнала или из любого асинхронного контекста.

Если обработчик сигнала вызовет небезопасную функцию, то может произойти:
* `Deadlock` (взаимная блокировка)
* `Corruption of data` (повреждение данных)
* `Undefined behavior` (неопределенное поведение)

Реентерабельная функция — функция, которую можно безопасно вызывать из нескольких потоков одновременно 
или рекурсивно из одного потока, без риска повреждения данных.

Свойства реентабкльной функции:
* Не использует статические/глобальные данные
* Не изменяет свои параметры (если не предназначена для этого)
* Не вызывает нереентерабельные функции
* Не использует статичные буферы