## Какие есть режимы работы у процессора и чем они отличаются?

x86-64 поддерживает несколько режимов (ring levels):
- Ring 0: ядро ОС (полный доступ)
- Ring 1-2: исторически использовались для драйверов
- Ring 3: пользовательские приложения (ограниченный доступ)
  Переход между кольцами происходит через прерывания, исключения или сисколлы

## Чем принципиально отличается вызов сисколла от вызова обычной функции? Что делает ассемблерная инструкция syscall?

Syscall — это не просто вызов функции. Это целая процедура в виде перевода процессора в привилегированный режим, снятие всего с регистров и пр.

**Полный путь сисколла в Linux x86-64:**
1. Пользовательский код помещает номер сисколла в `rax`, аргументы — в `rdi`, `rsi`, `rdx`, `r10`, `r8`, `r9`.
2. Выполняется инструкция `syscall`.
3. Процессор переключается в ring 0 (Ring 3 → Ring 0), сохраняет пользовательский `rip` в `rcx`, `rflags` в `r11`.
4. Прыгает на entry point сисколлов, заданный MSR (Model Specific Register).
5. Ядро выполняет работу, результат кладёт в `rax`.
6. `sysret` возвращает в пользовательский режим.

## Покажите пример кода, где она встречается.

* см. пример

## Покажите, как сделать сисколл `execve` напрямую через ассемблерную вставку.

```shell
  ausyscall execve
```

## Что такое привилегированные инструкции процессора и что к ним относится?

У процессора есть инструкции, которые можно выполнять исключительно в привилегированном режиме. Примером послужит LIDT (Load IDT) - инструкция, которая загружает таблицу векторов прерываний (interrupt vector table (IVT)).

Команду `lidt` можно вызвать только в привилегированном режиме.
Привилегированной же является лишь ОС. И у процессора есть отдельные флаги, обозначающие уровень привилегированности на текущий момент.
ОС же, перед тем, как отдать управление какому-либо процессу, ставит процессор в защищенный режим.