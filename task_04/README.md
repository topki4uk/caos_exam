# Формат ELF.

### ELF – executable linkable format, формат бинарных файлов для linux систем (.o и .out в том числе)

## Какие типы ELF-файлов существуют?

Существует 5 типов ELF-файлов:
* `Relocatable file` - еще не готовый файл, в него не вложены пути и адреса для исполнения сторонних 
    библиотек.

    Получить файл с пометкой REL можно при помощи команды:
    
    ```shell
      # Просто скомпилируем файлик
      g++ -c example.cpp -o relfile.o
    ```
  
    ```shell
      # Посмотрим на вывод программы readelf
      readelf -h relfile.o
    ```

* `Executable file` - исполняемый файл, но он содержит в себе все свои зависимости, а не линкуется с ними. Давайте тоже получим его:
    ```shell
      # Соберем файл с флагом -static
      g++ -static example.cpp -o executable
    ```
  
    ```shell
      # Посмотрим на вывод программы readelf
      readelf -h executable
    ```

* `DYN (Shared object file)` - либа, она линкуется с другими исполняемыми файлами, не имеет своей точки входа и не может быть запущена. Выполним следующие команды:
    ```shell
      # Соберем файл с флагом -shared
      g++ -shared shared.cpp -o shared.so
    ```

    ```shell
      # Посмотрим на вывод программы readelf
      readelf -h shared.so
    ```

* `DYN (Position-Independent Executable file)` - обычный исполняемый файлик. Выполним следующие команды:
    ```shell
      # Соберем файлик
      g++ example.cpp -o example
    ```

    ```shell
      # Посмотрим на вывод программы readelf
      readelf -h example
    ```

* `CORE (Core file)` - это кордамп файл, который мы получаем, если программа отработала некорректно. Выполним следующие команды:
    ```shell
      # Соберем файлик
      g++ -g corefile.cpp -o corefile
      ./corefile
    ```

    ```shell
      # Посмотрим на полученный coredump
      cd /var/lib/systemd/coredump
    ```
  
  ```shell
    # Запустим что-тоо типа
    zstd -d core.corefile.1000.85cb0da313a04c65acfe234740203bee.10530.1768305385000000.zst -o core.elf
    
    # Затем применим readelf для этого файла
  ```

# Что хранится в секциях strtab, shstrtab, interp, dynamic?

* `.strtab` - String Table. Это таблица, которая содержит имена символов для статической таблицы
  символов.
    ```text
      # readelf -x .strtab example
  
      Hex dump of section '.strtab':
      0x00000000 00536372 74312e6f 005f5f61 62695f74 .Scrt1.o.__abi_t
      0x00000010 61670063 72747374 7566662e 63006465 ag.crtstuff.c.de
      0x00000020 72656769 73746572 5f746d5f 636c6f6e register_tm_clon
      0x00000030 6573005f 5f646f5f 676c6f62 616c5f64 es.__do_global_d
      0x00000040 746f7273 5f617578 00636f6d 706c6574 tors_aux.complet
      0x00000050 65642e30 005f5f64 6f5f676c 6f62616c ed.0.__do_global
      0x00000060 5f64746f 72735f61 75785f66 696e695f _dtors_aux_fini_
      0x00000070 61727261 795f656e 74727900 6672616d array_entry.fram
      0x00000080 655f6475 6d6d7900 5f5f6672 616d655f e_dummy.__frame_
      0x00000090 64756d6d 795f696e 69745f61 72726179 dummy_init_array
      0x000000a0 5f656e74 72790065 78616d70 6c652e63 _entry.example.c
      0x000000b0 7070005f 5a4e5374 385f5f64 65746169 pp._ZNSt8__detai
      0x000000c0 6c33305f 5f696e74 65676572 5f746f5f l30__integer_to_
      0x000000d0 63686172 735f6973 5f756e73 69676e65 chars_is_unsigne
      0x000000e0 64496a45 45005f5a 4e537438 5f5f6465 dIjEE._ZNSt8__de
      0x000000f0 7461696c 33305f5f 696e7465 6765725f tail30__integer_
      0x00000100 746f5f63 68617273 5f69735f 756e7369 to_chars_is_unsi
      0x00000110 676e6564 496d4545 005f5a4e 5374385f gnedImEE._ZNSt8_
      0x00000120 5f646574 61696c33 305f5f69 6e746567 _detail30__integ
      0x00000130 65725f74 6f5f6368 6172735f 69735f75 er_to_chars_is_u
      0x00000140 6e736967 6e656449 79454500 5f5f4652 nsignedIyEE.__FR
      0x00000150 414d455f 454e445f 5f005f5f 474e555f AME_END__.__GNU_
      0x00000160 45485f46 52414d45 5f484452 005f4459 EH_FRAME_HDR._DY
      0x00000170 4e414d49 43005f47 4c4f4241 4c5f4f46 NAMIC._GLOBAL_OF
      0x00000180 46534554 5f544142 4c455f00 5f656461 FSET_TABLE_._eda
      0x00000190 7461005f 494f5f73 7464696e 5f757365 ta._IO_stdin_use
      0x000001a0 64005f5f 6378615f 66696e61 6c697a65 d.__cxa_finalize
      0x000001b0 40474c49 42435f32 2e322e35 006d6169 @GLIBC_2.2.5.mai
      0x000001c0 6e005f5f 64736f5f 68616e64 6c65005f n.__dso_handle._
      0x000001d0 66696e69 005f5f6c 6962635f 73746172 fini.__libc_star
      0x000001e0 745f6d61 696e4047 4c494243 5f322e33 t_main@GLIBC_2.3
      0x000001f0 34005f5a 53746c73 49537431 31636861 4._ZStlsISt11cha
      0x00000200 725f7472 61697473 49634545 52537431 r_traitsIcEERSt1
      0x00000210 33626173 69635f6f 73747265 616d4963 3basic_ostreamIc
      0x00000220 545f4553 355f504b 6340474c 49424358 T_ES5_PKc@GLIBCX
      0x00000230 585f332e 34005f69 6e697400 5f5f544d X_3.4._init.__TM
      0x00000240 435f454e 445f5f00 65786974 40474c49 C_END__.exit@GLI
      0x00000250 42435f32 2e322e35 005f5a53 7434636f BC_2.2.5._ZSt4co
      0x00000260 75744047 4c494243 58585f33 2e34005f ut@GLIBCXX_3.4._
      0x00000270 5f646174 615f7374 61727400 5f656e64 _data_start._end
      0x00000280 005f5f62 73735f73 74617274 005f5a53 .__bss_start._ZS
      0x00000290 74323169 6f735f62 6173655f 6c696272 t21ios_base_libr
      0x000002a0 6172795f 696e6974 7640474c 49424358 ary_initv@GLIBCX
      0x000002b0 585f332e 342e3332 005f4954 4d5f6465 X_3.4.32._ITM_de
      0x000002c0 72656769 73746572 544d436c 6f6e6554 registerTMCloneT
      0x000002d0 61626c65 005f5f67 6d6f6e5f 73746172 able.__gmon_star
      0x000002e0 745f5f00 5f49544d 5f726567 69737465 t__._ITM_registe
      0x000002f0 72544d43 6c6f6e65 5461626c 6500     rTMCloneTable.
    ```
* `.shstrtab` - Section Header String Table — таблица строк для заголовков секций. Содержит имена самих секций (`.text`, `.data`, `.strtab` и т.д.).
  ```text
    # readelf -x .shstrtab example
    
    Hex dump of section '.shstrtab':
    0x00000000 002e7379 6d746162 002e7374 72746162 ..symtab..strtab
    0x00000010 002e7368 73747274 6162002e 696e7465 ..shstrtab..inte
    0x00000020 7270002e 6e6f7465 2e676e75 2e70726f rp..note.gnu.pro
    0x00000030 70657274 79002e6e 6f74652e 676e752e perty..note.gnu.
    0x00000040 6275696c 642d6964 002e6e6f 74652e41 build-id..note.A
    0x00000050 42492d74 6167002e 676e752e 68617368 BI-tag..gnu.hash
    0x00000060 002e6479 6e73796d 002e6479 6e737472 ..dynsym..dynstr
    0x00000070 002e676e 752e7665 7273696f 6e002e67 ..gnu.version..g
    0x00000080 6e752e76 65727369 6f6e5f72 002e7265 nu.version_r..re
    0x00000090 6c612e64 796e002e 72656c61 2e706c74 la.dyn..rela.plt
    0x000000a0 002e696e 6974002e 706c742e 676f7400 ..init..plt.got.
    0x000000b0 2e706c74 2e736563 002e7465 7874002e .plt.sec..text..
    0x000000c0 66696e69 002e726f 64617461 002e6568 fini..rodata..eh
    0x000000d0 5f667261 6d655f68 6472002e 65685f66 _frame_hdr..eh_f
    0x000000e0 72616d65 002e696e 69745f61 72726179 rame..init_array
    0x000000f0 002e6669 6e695f61 72726179 002e6479 ..fini_array..dy
    0x00000100 6e616d69 63002e64 61746100 2e627373 namic..data..bss
    0x00000110 002e636f 6d6d656e 7400              ..comment.
  ```

* `.interp` - Interpreter Path — путь к интерпретатору. Содержит путь к динамическому загрузчику 
  (линкеру времени выполнения) — программе, которая загружает разделяемые библиотеки и разрешает динамические символы перед запуском программы.

  ```text
    # readelf -x .interp example
  
    Hex dump of section '.interp':
    0x00000318 2f6c6962 36342f6c 642d6c69 6e75782d /lib64/ld-linux-
    0x00000328 7838362d 36342e73 6f2e3200          x86-64.so.2.
  ```
  
* `.dynamic` - Dynamic Linking Information.  Главная структура данных для динамической линковки. Содержит "оглавление" информации, необходимой динамическому загрузчику.

  ```text
    # readelf -x .dynamic example
  
    Hex dump of section '.dynamic':
    0x00003db0 01000000 00000000 cb000000 00000000 ................
    0x00003dc0 01000000 00000000 da000000 00000000 ................
    0x00003dd0 0c000000 00000000 00100000 00000000 ................
    0x00003de0 0d000000 00000000 94110000 00000000 ................
    0x00003df0 19000000 00000000 a03d0000 00000000 .........=......
    0x00003e00 1b000000 00000000 08000000 00000000 ................
    0x00003e10 1a000000 00000000 a83d0000 00000000 .........=......
    0x00003e20 1c000000 00000000 08000000 00000000 ................
    0x00003e30 f5feff6f 00000000 b0030000 00000000 ...o............
    0x00003e40 05000000 00000000 c8040000 00000000 ................
    0x00003e50 06000000 00000000 d8030000 00000000 ................
    0x00003e60 0a000000 00000000 16010000 00000000 ................
    0x00003e70 0b000000 00000000 18000000 00000000 ................
    0x00003e80 15000000 00000000 00000000 00000000 ................
    0x00003e90 03000000 00000000 b03f0000 00000000 .........?......
    0x00003ea0 02000000 00000000 30000000 00000000 ........0.......
    0x00003eb0 14000000 00000000 07000000 00000000 ................
    0x00003ec0 17000000 00000000 30070000 00000000 ........0.......
    0x00003ed0 07000000 00000000 58060000 00000000 ........X.......
    0x00003ee0 08000000 00000000 d8000000 00000000 ................
    0x00003ef0 09000000 00000000 18000000 00000000 ................
    0x00003f00 1e000000 00000000 08000000 00000000 ................
    0x00003f10 fbffff6f 00000000 01000008 00000000 ...o............
    0x00003f20 feffff6f 00000000 f8050000 00000000 ...o............
    0x00003f30 ffffff6f 00000000 02000000 00000000 ...o............
    0x00003f40 f0ffff6f 00000000 de050000 00000000 ...o............
    0x00003f50 f9ffff6f 00000000 03000000 00000000 ...o............
    0x00003f60 00000000 00000000 00000000 00000000 ................
    0x00003f70 00000000 00000000 00000000 00000000 ................
    0x00003f80 00000000 00000000 00000000 00000000 ................
    0x00003f90 00000000 00000000 00000000 00000000 ................
    0x00003fa0 00000000 00000000 00000000 00000000 ................
  ```

# Какие есть утилиты для чтения содержимого ELF-файлов?

* `readelf` - читает и обрабатывает все содержимое ELF файла
* `objdump` - получает из ELF файла данные, после дизасемблирует и форматировано выводит 
* `hexdump` - аналогично `objdump`
* `nm` - получает из ELF файла таблицу символов

# Для чего нужна утилита `objcopy`?

Утилита `objcopy` нужна для редактирования ELF файла. Например, мы можем вносить изменения в уже собранный файл и не тратить время
на его повторную сборку.

Приведем следующие примеры:
```shell
  # Сгенерим файл с дебаг информацией
  g++ -g example.cpp -o debug_example
```

```shell
  # Применим objcopy для удаления дебаг информации из файла
  objcopy --strip-debug debug_example stripped_example
```

```shell
  # Применим objcopy для удаления просто ненужной информации из файла (применяется когда надо отправить код на прод)
  objcopy --strip-unneeded example production_example
```

```shell
  # Посмотрим на размеры файликов
  ls -lh debug_example stripped_example production_example
```