# Что такое линковка?
Линковка – связывание нескольких объектных файлов. Находятся определения функций из внешних
библиотек. Она, в свою очередь, включает в себя 2 этапа – статический и динамический.

### Линковка выполняется командой `ld`

```bash
    # Линковка вручную
    ld -e main example.o -lc -l:libstdc++.so.6 -lm \
     -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o a.out
```

Для линковщика `ld` необходимо указать либы, которые ему надо подтянуть, также добавляем точку входа через флаг `-e`, 
иначе программа просто не найдет начало исполнения. Чтобы после сборки программа запустилась, мы указываем адрес динамического
линкера `-dynamic-linker`, который отвечает за получение зависимостей во время запуска.

```bash
    # Просмотр зависимостей
    ldd a.out
```

# Что такое либы?
Библиотеки (либы) - уже скомпилированные ELF файлы, в которой находятся символы, но уже с
определениями. Общепринято называть либы начиная с `lib`. Либы бывают статические и динамические.
Статические имеют расширение `.lib` или `.a`, динамические – `.so`.

* Статическая линковка - весь необходимый код из библиотек объединяется с объектным кодом программы в один исполняемый файл
    на этапе компиляции. Это означает, что все функции из библиотек присутствуют в итоговом исполняемом файле, и программа не зависит от наличия библиотек на
целевой системе.

* Динамическая линковка - код библиотеки не включается в исполняемый файл, а используется во
  время выполнения программы. Это позволяет нескольким программам использовать одну и ту же
  библиотеку, что экономит дисковое пространство

Разберем создание `.so` файлов и `.a` файлов:

```shell
    # Для .so файлов  
    g++ -shared square.cpp -o libsquare.so
```

```shell
    # Соберем программу с .so файлом
    # Для этого придется указывать вспомогательную инфу для стат. и динам. линкеров
    g++ square_func.cpp -L. -lsquare \
      -Wl,-rpath=/home/alex/CLionProjects/caos_exam/task_02/ -o a.out
```

Теперь рассмотрим создание `.a` библиотек:

```shell
    # Генерим объектники
    g++ -c square.cpp -o libsqure.o
    g++ -c cube.cpp -o libcube.o
    g++ -c pi.cpp -o libpi.o
    
    # Собираем либу
    ar rcs libmath.a libsqure.o libcube.o libpi.o
```

```shell
    # Посмотреть внутренности статической либы
    ar t libmath.a
```

```shell
    # Линковка с либой
    g++ square_func.cpp -L. -lmath -o a.out
```

## Для чего нужны переменные LD_PRELOAD, LD_LIBRARY_PATH?

```shell
    # Есть другие способы линковки, например, через флаг LD_LIBRARY_PATH
    g++ square_func.cpp -L. -lsquare -o a.out  # Не указываем пути для дин. линкера
    LD_LIBRARY_PATH=. ./a.out                  # Указываем сразу при запуске
```

```shell
    # Посмотрим на зависимости файла
    LD_LIBRARY_PATH=. ldd ./a.out 
```

Теперь про `LD_PRELOAD`:

Представим, что нам надо запустить свою костомную либу вместо стандартной, тогда нам надо переопределить ее:

```shell
    # Для начала переместим какую-нибудь стандартную либу в эту папку
    cp /lib/x86_64-linux-gnu/libstdc++.so.6 .
```

```shell
    # Теперь подменим стандартную либу нашей кастомной
    g++ example.cpp -o a.out
    LD_PRELOAD="./libstdc++.so.6" ./a.out
```

```shell
    # Посмотрим на зависимости
    LD_PRELOAD="./libstdc++.so.6" ldd ./a.out
```

## Как посмотреть, какие вызовы библиотечных функций делает данная программа в ходе выполнения?

Для просмотра библиотечных функций можно воспользоваться утилитой `ltrace`:

```shell
    # Вызов функции ltrace
    ltrace ./a.out
```